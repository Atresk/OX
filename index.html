<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1132928-FinalTerm</title>
    <style>
        body {
            font-family: 'Microsoft JhengHei', 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c3e50, #34495e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #ecf0f1;
        }
        .game-container {
            text-align: center;
            background: rgba(0,0,0,0.6);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            backdrop-filter: blur(10px);
        }
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #f39c12, #e67e22);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .status {
            font-size: 1.1em;
            margin: 15px 0;
            padding: 12px;
            background: rgba(52, 73, 94, 0.9);
            border-radius: 10px;
            border-left: 5px solid #3498db;
            transition: all 0.3s;
        }
        
        /* --- æ£‹ç›¤æ ¸å¿ƒæ¨£å¼ä¿®æ­£ --- */
        #board {
            display: grid;
            grid-template-columns: repeat(9, 45px); /* ç¸®å°ä¸€é»ä»¥é©æ‡‰è¢å¹• */
            grid-template-rows: repeat(9, 45px);
            margin: 20px auto;
            padding: 20px;
            background: #DCB35C; /* å¯¦æœ¨è‰² */
            border-radius: 5px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            position: relative;
        }

        .cell {
            width: 45px;
            height: 45px;
            position: relative;
            cursor: pointer;
            /* å–æ¶ˆåŸæœ¬çš„æ ¼å­èƒŒæ™¯ï¼Œæ”¹ç”¨ç·šæ¢ */
            background: transparent; 
        }

        /* ç¹ªè£½æ©«ç·š */
        .cell::before {
            content: '';
            position: absolute;
            top: 50%; left: 0; right: 0;
            height: 1px;
            background: #000;
            z-index: 0;
        }
        /* ç¹ªè£½ç›´ç·š */
        .cell::after {
            content: '';
            position: absolute;
            top: 0; bottom: 0; left: 50%;
            width: 1px;
            background: #000;
            z-index: 0;
        }

        /* è™•ç†é‚Šç·£ç·šæ¢ï¼Œä¸è®“ç·šå‡¸å‡ºå» */
        .cell[data-col="0"]::before { left: 50%; }
        .cell[data-col="8"]::before { right: 50%; }
        .cell[data-row="0"]::after { top: 50%; }
        .cell[data-row="8"]::after { bottom: 50%; }

        /* å¤©å…ƒèˆ‡æ˜Ÿä½ (3,3), (3,7), (7,3), (7,7), (5,5) */
        .cell.star::before {
            /* åˆ©ç”¨ä¸€å€‹å°åœ“é»è¦†è“‹ */
            box-shadow: 0 0 0 2px #000; 
        }
        /* ä½¿ç”¨å½å…ƒç´ ç•«æ˜Ÿä½é»‘é» */
        .star-point {
            position: absolute;
            width: 6px; height: 6px;
            background: #000;
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
        }

        /* --- æ£‹å­æ¨£å¼ --- */
        .stone {
            width: 85%;
            height: 85%;
            border-radius: 50%;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0); /* åˆå§‹ç¸®æ”¾ç‚º0 */
            z-index: 2;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
        }

        .cell.has-stone .stone {
            transform: translate(-50%, -50%) scale(1);
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #444 0%, #000 100%);
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #fff 0%, #ddd 100%);
        }

        /* æœ€å¾Œä¸€æ‰‹æ¨™è¨˜ */
        .last-move-marker {
            position: absolute;
            width: 30%; height: 30%;
            background: rgba(255, 0, 0, 0.8);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            box-shadow: 0 0 5px red;
        }
        
        /* æå­å‹•ç•« */
        .captured-anim {
            animation: fadeOut 0.5s forwards;
        }
        @keyframes fadeOut {
            to { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        }

        /* --- UI æ§åˆ¶é … --- */
        .controls { margin-top: 20px; }
        button {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white; border: none; padding: 10px 20px;
            margin: 0 5px; border-radius: 20px; font-size: 14px;
            cursor: pointer; transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 10px rgba(0,0,0,0.3); }
        button:disabled { background: #7f8c8d; cursor: not-allowed; transform: none; }
        .pass-btn { background: linear-gradient(45deg, #e67e22, #d35400) !important; }
        .reset-btn { background: linear-gradient(45deg, #e74c3c, #c0392b) !important; }

        .score-board {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        .score-box {
            background: rgba(255,255,255,0.1);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .score-num { font-size: 1.5em; font-weight: bold; display: block; }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="status" id="status">ğŸ–¤ è¼ªåˆ°é»‘æ£‹ (User)</div>
        
        <div id="board">
            </div>

        <div class="controls">
            <button onclick="game.reset()">ğŸ”„ æ–°å±€</button>
            <button class="pass-btn" onclick="game.pass()">ğŸ³ï¸ è™›æ‰‹ (Pass)</button>
            <button onclick="game.undo()" id="undoBtn">â†©ï¸ æ‚”æ£‹</button>
        </div>

        <div class="score-board">
            <div class="score-box">
                <span>é»‘æ£‹ (ç©å®¶)</span>
                <span id="blackScore" class="score-num">0</span>
            </div>
            <div class="score-box">
                <span>ç™½æ£‹ (é›»è…¦)</span>
                <span id="whiteScore" class="score-num">0</span>
            </div>
        </div>
        <div style="font-size: 0.8rem; color: #aaa; margin-top:10px;">
            é›™æ–¹é€£çºŒ Pass å³çµ‚å±€
        </div>
    </div>

    <script>
        class GoGame {
            constructor() {
                this.boardSize = 9;
                this.boardElement = document.getElementById('board');
                this.statusElement = document.getElementById('status');
                this.blackScoreEl = document.getElementById('blackScore');
                this.whiteScoreEl = document.getElementById('whiteScore');
                
                this.reset();
            }

            reset() {
                // 0: ç©º, 1: é»‘, 2: ç™½
                this.grid = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
                this.history = []; // ç”¨æ–¼æ‚”æ£‹
                this.boardHistoryHashes = []; // ç”¨æ–¼æ‰“åŠ«åˆ¤æ–· (Ko rule)
                this.currentPlayer = 1; // é»‘å…ˆ
                this.passCount = 0;
                this.isGameOver = false;
                this.lastMove = null;

                this.renderBoard();
                this.updateUI();
            }

            // åˆå§‹åŒ–æ£‹ç›¤ DOM
            renderBoard() {
                this.boardElement.innerHTML = '';
                const starPoints = [[2,2], [6,2], [4,4], [2,6], [6,6]]; // 9è·¯æ˜Ÿä½

                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        
                        // ç¹ªè£½æ˜Ÿä½
                        if (starPoints.some(p => p[0] === x && p[1] === y)) {
                            const star = document.createElement('div');
                            star.className = 'star-point';
                            cell.appendChild(star);
                        }

                        // æ£‹å­å®¹å™¨
                        const stone = document.createElement('div');
                        stone.className = 'stone'; // é è¨­éš±è—
                        cell.appendChild(stone);

                        cell.addEventListener('click', () => this.handleUserClick(x, y));
                        this.boardElement.appendChild(cell);
                    }
                }
            }

            handleUserClick(x, y) {
                if (this.isGameOver || this.currentPlayer !== 1) return;
                
                if (this.attemptMove(x, y, 1)) {
                    // é›»è…¦å›æ‡‰
                    setTimeout(() => this.computerMove(), 500);
                }
            }

            attemptMove(x, y, color) {
                if (this.grid[y][x] !== 0) return false; // å·²æœ‰å­

                // è¤‡è£½æ£‹ç›¤é€²è¡Œæ¨¡æ“¬
                let tempGrid = JSON.parse(JSON.stringify(this.grid));
                tempGrid[y][x] = color;

                // 1. æª¢æŸ¥æå­ (Capture)
                const opponent = color === 1 ? 2 : 1;
                const capturedStones = this.checkCaptures(tempGrid, x, y, opponent);
                
                // 2. æª¢æŸ¥ç¦è‘—é» (Suicide): å¦‚æœæ²’åƒåˆ°äººï¼Œä¸”è‡ªå·±æ°£ç‚º0 -> ç¦æ­¢
                if (capturedStones.length === 0 && this.getLiberties(x, y, tempGrid) === 0) {
                    this.showStatus("âŒ ç¦è‘—é» (è‡ªæ®º)ï¼");
                    return false;
                }

                // 3. æª¢æŸ¥æ‰“åŠ« (Ko): å±€é¢ä¸èƒ½èˆ‡ä¸Šä¸€æ­¥å®Œå…¨ç›¸åŒ
                // é€™è£¡ç°¡åŒ–ï¼šæ¯”å° Hashï¼Œå¦‚æœè·Ÿä¸Šä¸€æ‰‹çµæŸå¾Œçš„å±€é¢ä¸€æ¨£å‰‡ç¦æ­¢
                // æ­£ç¢ºçš„ Ko è¦å‰‡æ˜¯ä¸èƒ½å›å¾©åˆ°"å…¨å±€åŒå‹"ã€‚
                const newBoardHash = JSON.stringify(tempGrid);
                if (this.boardHistoryHashes.includes(newBoardHash) && this.boardHistoryHashes.indexOf(newBoardHash) === this.boardHistoryHashes.length - 1) {
                    // ç°¡æ˜“åŠ«ï¼šåªæ“‹ç«‹å³åæ
                    // åš´æ ¼åŠ«ï¼šthis.boardHistoryHashes.includes(newBoardHash)
                    // é€™è£¡æ¡ç”¨ç°¡æ˜“åŠ« (Basic Ko) é¿å…è¤‡é›œé©—è­‰å›°æ“¾
                     if (this.lastMove && capturedStones.length === 1 && this.history.length > 0) {
                        // å¦‚æœé€™ä¸€æ­¥åªæäº†ä¸€å­ï¼Œä¸”å›å¾©åˆ°ä¸Šä¸€æ­¥ç‹€æ…‹ -> ç¦æ­¢
                        // ç°¡åŒ–åˆ¤å®šï¼šæª¢æŸ¥ hash
                        if (this.boardHistoryHashes.length > 1 && newBoardHash === this.boardHistoryHashes[this.boardHistoryHashes.length - 2]) {
                             this.showStatus("âŒ æ‰“åŠ« (Ko)ï¼è«‹æ‰¾åŠ«æã€‚");
                             return false;
                        }
                     }
                }

                // --- åˆæ³•ç§»å‹•ï¼ŒåŸ·è¡Œ ---
                this.executeMove(x, y, color, capturedStones);
                return true;
            }

            executeMove(x, y, color, capturedStones) {
                // å­˜å…¥æ­·å²
                this.history.push(JSON.parse(JSON.stringify(this.grid)));
                
                // æ›´æ–°æ£‹ç›¤
                this.grid[y][x] = color;
                
                // ç§»é™¤æ­»å­
                capturedStones.forEach(pos => {
                    this.grid[pos.y][pos.x] = 0;
                });

                // æ›´æ–° Hash
                this.boardHistoryHashes.push(JSON.stringify(this.grid));
                if (this.boardHistoryHashes.length > 6) this.boardHistoryHashes.shift(); // ä¿æŒè¨˜æ†¶é«”è¼•é‡

                this.lastMove = {x, y};
                this.passCount = 0; // é‡ç½® pass
                this.currentPlayer = color === 1 ? 2 : 1;
                
                this.updateView(x, y, color, capturedStones);
                this.updateUI();
            }

            checkCaptures(board, lastX, lastY, opponentColor) {
                let captured = [];
                const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                
                // æª¢æŸ¥å‰›è½å­å››å‘¨çš„æ•µå­
                dirs.forEach(([dx, dy]) => {
                    const nx = lastX + dx, ny = lastY + dy;
                    if (this.isOnBoard(nx, ny) && board[ny][nx] === opponentColor) {
                        const group = this.getGroup(nx, ny, board);
                        if (group.liberties === 0) {
                            captured.push(...group.stones);
                        }
                    }
                });
                return captured;
            }

            getGroup(x, y, board) {
                const color = board[y][x];
                let stones = [];
                let liberties = 0;
                let visited = new Set();
                let queue = [{x, y}];
                visited.add(`${x},${y}`);

                while (queue.length > 0) {
                    const curr = queue.pop();
                    stones.push(curr);
                    
                    const dirs = [[0,1], [0,-1], [1,0], [-1,0]];
                    dirs.forEach(([dx, dy]) => {
                        const nx = curr.x + dx, ny = curr.y + dy;
                        if (this.isOnBoard(nx, ny)) {
                            const neighborColor = board[ny][nx];
                            if (neighborColor === 0) {
                                liberties++;
                            } else if (neighborColor === color && !visited.has(`${nx},${ny}`)) {
                                visited.add(`${nx},${ny}`);
                                queue.push({x: nx, y: ny});
                            }
                        }
                    });
                }
                return { stones, liberties };
            }

            getLiberties(x, y, board) {
                return this.getGroup(x, y, board).liberties;
            }

            isOnBoard(x, y) {
                return x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize;
            }

            // --- UI æ›´æ–° ---
            updateView(newX, newY, color, capturedStones) {
                // ç§»é™¤æ­»å­é¡¯ç¤º
                capturedStones.forEach(pos => {
                    const cell = document.querySelector(`.cell[data-x="${pos.x}"][data-y="${pos.y}"]`);
                    const stone = cell.querySelector('.stone');
                    stone.classList.add('captured-anim');
                    setTimeout(() => {
                        stone.className = 'stone'; // é‡ç½®
                        cell.classList.remove('has-stone');
                    }, 200);
                });

                // æ–°å¢æ£‹å­
                const cell = document.querySelector(`.cell[data-x="${newX}"][data-y="${newY}"]`);
                const stone = cell.querySelector('.stone');
                stone.className = `stone ${color === 1 ? 'black' : 'white'}`;
                cell.classList.add('has-stone');

                // æ›´æ–°æœ€å¾Œä¸€æ‰‹ç´…é»
                document.querySelectorAll('.last-move-marker').forEach(el => el.remove());
                const marker = document.createElement('div');
                marker.className = 'last-move-marker';
                cell.appendChild(marker);
            }

            updateUI() {
                if (this.isGameOver) return;
                
                // ç°¡å–®è¨ˆç®—ç›¤é¢å­æ•¸ (ä¸ä»£è¡¨çµ‚å±€åˆ†æ•¸)
                let b = 0, w = 0;
                this.grid.flat().forEach(c => { if(c===1) b++; if(c===2) w++; });
                
                this.blackScoreEl.innerText = b;
                this.whiteScoreEl.innerText = w;

                const name = this.currentPlayer === 1 ? "é»‘æ£‹ (User)" : "ç™½æ£‹ (CPU)";
                this.statusElement.innerText = `è¼ªåˆ°ï¼š${name}`;
                this.statusElement.style.borderLeftColor = this.currentPlayer === 1 ? "#000" : "#fff";
            }

            // --- é›»è…¦ AI (Heuristic) ---
            computerMove() {
                if (this.isGameOver) return;

                let bestMove = null;
                let maxScore = -Infinity;
                const candidates = [];

                // éæ­·æ‰€æœ‰åˆæ³•é»
                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        if (this.grid[y][x] === 0) {
                            // ç°¡å–®æ¨¡æ“¬ï¼šæ¸¬è©¦é€™æ­¥æ£‹çš„åˆ†æ•¸
                            let score = Math.random() * 5; // åŸºç¤éš¨æ©Ÿåˆ†
                            
                            // æ¨¡æ“¬è½å­
                            let tempGrid = JSON.parse(JSON.stringify(this.grid));
                            tempGrid[y][x] = 2; // ç™½æ£‹
                            
                            // 1. æ”»æ“Šï¼šèƒ½å¦æåƒç©å®¶
                            const caps = this.checkCaptures(tempGrid, x, y, 1);
                            if (caps.length > 0) score += 50 + caps.length * 20;

                            // 2. é˜²å®ˆï¼šè‡ªå·±æœƒä¸æœƒæ­» (è‡ªæ®ºæª¢æŸ¥)
                            const myGroup = this.getGroup(x, y, tempGrid);
                            if (myGroup.liberties === 0 && caps.length === 0) continue; // è‡ªæ®ºï¼Œè·³é
                            if (myGroup.liberties === 1) score -= 50; // å¡«å…¥è™å£ï¼Œå±éšª

                            // 3. ä½”åœ°ï¼šå„ªå…ˆä½”è§’é‚Š (9è·¯ç‰¹åŒ–)
                            if ((x===2 || x===6) && (y===2 || y===6)) score += 10; // 3-3
                            if (x===4 && y===4) score += 8; // å¤©å…ƒ

                            // 4. æ•‘å­ï¼šå¦‚æœæœ‰å·±æ–¹æ£‹å­è¢«å«åƒï¼Œå˜—è©¦æ•‘æ´
                            // (æ­¤è™•ç°¡åŒ–ï¼Œåƒ…çœ‹è½å­å¾Œæ˜¯å¦å¢åŠ æ°£)
                            
                            candidates.push({x, y, score});
                        }
                    }
                }

                if (candidates.length === 0) {
                    this.pass();
                    return;
                }

                // é¸æ“‡æœ€é«˜åˆ†
                candidates.sort((a, b) => b.score - a.score);
                bestMove = candidates[0];

                this.attemptMove(bestMove.x, bestMove.y, 2);
            }

            pass() {
                this.passCount++;
                this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                this.statusElement.innerText = `âš ï¸ ${this.currentPlayer === 2 ? 'é»‘æ£‹' : 'ç™½æ£‹'} Pass! (${this.passCount}/2)`;
                
                if (this.passCount >= 2) {
                    this.endGame();
                } else if (this.currentPlayer === 2) {
                    setTimeout(() => this.computerMove(), 1000);
                }
            }

            undo() {
                if (this.history.length === 0 || this.isGameOver) return;
                
                // å›å¾©å…©æ­¥ (å› ç‚ºæ˜¯ä¸€äººä¸€æ­¥)
                // å¦‚æœæ˜¯ç©å®¶å‰›ä¸‹å®Œé›»è…¦é‚„æ²’ä¸‹ï¼Œé€™é‚è¼¯è¦èª¿æ•´ã€‚ä½†å› ç‚ºsetTimeoutï¼Œé€šå¸¸å·²ç¶“ä¸‹å®Œäº†ã€‚
                // ç°¡å–®åšï¼šå›å¾©åˆ°ä¸Šä¸€æ¬¡ç©å®¶è½å­å‰çš„ç‹€æ…‹ (å³ pop å…©æ¬¡)
                
                if (this.history.length >= 2) {
                    this.history.pop(); // Pop computer move
                    this.history.pop(); // Pop user move
                    this.grid = this.history.length > 0 ? JSON.parse(JSON.stringify(this.history[this.history.length-1])) : Array(9).fill().map(()=>Array(9).fill(0));
                } else {
                    // åªä¸‹äº†ä¸€æ‰‹æˆ–å‰›é–‹å§‹
                    this.reset();
                    return;
                }
                
                // é‡æ–°æ¸²æŸ“å…¨éƒ¨
                this.boardElement.innerHTML = ''; 
                this.renderBoard(); 
                // æ¢å¾©æ£‹ç›¤ç‹€æ…‹
                for(let y=0; y<9; y++) {
                    for(let x=0; x<9; x++) {
                        if(this.grid[y][x] !== 0) {
                            this.updateView(x, y, this.grid[y][x], []);
                        }
                    }
                }
                this.currentPlayer = 1;
                this.passCount = 0;
                this.updateUI();
            }

            endGame() {
                this.isGameOver = true;
                
                // --- æ•¸å­æ³•çµç®— (Chinese Counting / Area Scoring) ---
                // å­ + ç©º (æ­¸å±¬æ–¼è©²è‰²çš„ç©ºåœ°)
                let blackArea = 0;
                let whiteArea = 0;
                let visited = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(false));

                for (let y = 0; y < this.boardSize; y++) {
                    for (let x = 0; x < this.boardSize; x++) {
                        if (this.grid[y][x] === 1) blackArea++;
                        else if (this.grid[y][x] === 2) whiteArea++;
                        else if (!visited[y][x]) {
                            // æ´ªæ°´å¡«å……è¨ˆç®—ç©ºåœ°æ­¸å±¬
                            let region = [];
                            let q = [{x, y}];
                            visited[y][x] = true;
                            let touchBlack = false, touchWhite = false;

                            while(q.length > 0) {
                                let c = q.pop();
                                region.push(c);
                                [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dx,dy]) => {
                                    let nx = c.x+dx, ny = c.y+dy;
                                    if(this.isOnBoard(nx,ny)) {
                                        if(this.grid[ny][nx] === 1) touchBlack = true;
                                        else if(this.grid[ny][nx] === 2) touchWhite = true;
                                        else if(!visited[ny][nx]) {
                                            visited[ny][nx] = true;
                                            q.push({x:nx, y:ny});
                                        }
                                    }
                                });
                            }

                            if(touchBlack && !touchWhite) blackArea += region.length;
                            else if(touchWhite && !touchBlack) whiteArea += region.length;
                        }
                    }
                }

                // è²¼ç›® (Komi) 5.5
                let finalWhite = whiteArea + 5.5;
                let resultText = `é»‘æ£‹: ${blackArea} å­\nç™½æ£‹: ${finalWhite} å­ (å«è²¼ç›®)\n`;
                resultText += blackArea > finalWhite ? "ğŸ† é»‘æ£‹ç²å‹ï¼" : "ğŸ’» ç™½æ£‹ç²å‹ï¼";

                this.statusElement.innerText = "ğŸ éŠæˆ²çµæŸ";
                this.statusElement.style.background = "#e74c3c";
                
                setTimeout(() => alert(resultText), 100);
            }
        }

        // å•Ÿå‹•éŠæˆ²
        const game = new GoGame();
    </script>
</body>
</html>